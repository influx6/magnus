{
  "app.js": {
    "id": "app.js",
    "type": "js",
    "mtime": 1423593601000,
    "src": "",
    "deps": {},
    "entry": true
  },
  "build/app.js": {
    "id": "build/app.js",
    "type": "js",
    "mtime": 1423593969000,
    "src": "(function outer(modules, cache, entries){\n\n  /**\n   * Global\n   */\n\n  var global = (function(){ return this; })();\n\n  /**\n   * Require `name`.\n   *\n   * @param {String} name\n   * @param {Boolean} jumped\n   * @api public\n   */\n\n  function require(name, jumped){\n    if (cache[name]) return cache[name].exports;\n    if (modules[name]) return call(name, require);\n    throw new Error('cannot find module \"' + name + '\"');\n  }\n\n  /**\n   * Call module `id` and cache it.\n   *\n   * @param {Number} id\n   * @param {Function} require\n   * @return {Function}\n   * @api private\n   */\n\n  function call(id, require){\n    var m = cache[id] = { exports: {} };\n    var mod = modules[id];\n    var name = mod[2];\n    var fn = mod[0];\n\n    fn.call(m.exports, function(req){\n      var dep = modules[id][1][req];\n      return require(dep ? dep : req);\n    }, m, m.exports, outer, modules, cache, entries);\n\n    // expose as `name`.\n    if (name) cache[name] = cache[id];\n\n    return cache[id].exports;\n  }\n\n  /**\n   * Require all entries exposing them on global if needed.\n   */\n\n  for (var id in entries) {\n    if (entries[id]) {\n      global[entries[id]] = require(id);\n    } else {\n      require(id);\n    }\n  }\n\n  /**\n   * Duo flag.\n   */\n\n  require.duo = true;\n\n  /**\n   * Expose cache.\n   */\n\n  require.cache = cache;\n\n  /**\n   * Expose modules\n   */\n\n  require.modules = modules;\n\n  /**\n   * Return newest require.\n   */\n\n   return require;\n})({\n1: [function(require, module, exports) {\n\n}, {}]}, {}, {\"1\":\"\"})\n",
    "deps": {},
    "entry": true
  },
  "build/build/app.js": {
    "id": "build/build/app.js",
    "type": "js",
    "mtime": 1423593910000,
    "src": "(function outer(modules, cache, entries){\n\n  /**\n   * Global\n   */\n\n  var global = (function(){ return this; })();\n\n  /**\n   * Require `name`.\n   *\n   * @param {String} name\n   * @param {Boolean} jumped\n   * @api public\n   */\n\n  function require(name, jumped){\n    if (cache[name]) return cache[name].exports;\n    if (modules[name]) return call(name, require);\n    throw new Error('cannot find module \"' + name + '\"');\n  }\n\n  /**\n   * Call module `id` and cache it.\n   *\n   * @param {Number} id\n   * @param {Function} require\n   * @return {Function}\n   * @api private\n   */\n\n  function call(id, require){\n    var m = cache[id] = { exports: {} };\n    var mod = modules[id];\n    var name = mod[2];\n    var fn = mod[0];\n\n    fn.call(m.exports, function(req){\n      var dep = modules[id][1][req];\n      return require(dep ? dep : req);\n    }, m, m.exports, outer, modules, cache, entries);\n\n    // expose as `name`.\n    if (name) cache[name] = cache[id];\n\n    return cache[id].exports;\n  }\n\n  /**\n   * Require all entries exposing them on global if needed.\n   */\n\n  for (var id in entries) {\n    if (entries[id]) {\n      global[entries[id]] = require(id);\n    } else {\n      require(id);\n    }\n  }\n\n  /**\n   * Duo flag.\n   */\n\n  require.duo = true;\n\n  /**\n   * Expose cache.\n   */\n\n  require.cache = cache;\n\n  /**\n   * Expose modules\n   */\n\n  require.modules = modules;\n\n  /**\n   * Return newest require.\n   */\n\n   return require;\n})({\n1: [function(require, module, exports) {\n(function outer(modules, cache, entries){\n\n  /**\n   * Global\n   */\n\n  var global = (function(){ return this; })();\n\n  /**\n   * Require `name`.\n   *\n   * @param {String} name\n   * @param {Boolean} jumped\n   * @api public\n   */\n\n  function require(name, jumped){\n    if (cache[name]) return cache[name].exports;\n    if (modules[name]) return call(name, require);\n    throw new Error('cannot find module \"' + name + '\"');\n  }\n\n  /**\n   * Call module `id` and cache it.\n   *\n   * @param {Number} id\n   * @param {Function} require\n   * @return {Function}\n   * @api private\n   */\n\n  function call(id, require){\n    var m = cache[id] = { exports: {} };\n    var mod = modules[id];\n    var name = mod[2];\n    var fn = mod[0];\n\n    fn.call(m.exports, function(req){\n      var dep = modules[id][1][req];\n      return require(dep ? dep : req);\n    }, m, m.exports, outer, modules, cache, entries);\n\n    // expose as `name`.\n    if (name) cache[name] = cache[id];\n\n    return cache[id].exports;\n  }\n\n  /**\n   * Require all entries exposing them on global if needed.\n   */\n\n  for (var id in entries) {\n    if (entries[id]) {\n      global[entries[id]] = require(id);\n    } else {\n      require(id);\n    }\n  }\n\n  /**\n   * Duo flag.\n   */\n\n  require.duo = true;\n\n  /**\n   * Expose cache.\n   */\n\n  require.cache = cache;\n\n  /**\n   * Expose modules\n   */\n\n  require.modules = modules;\n\n  /**\n   * Return newest require.\n   */\n\n   return require;\n})({\n1: [function(require, module, exports) {\n\n}, {}]}, {}, {\"1\":\"\"})\n\n}, {}]}, {}, {\"1\":\"\"})\n",
    "deps": {},
    "entry": true
  },
  "magnus.js": {
    "id": "magnus.js",
    "type": "js",
    "mtime": 1423759822000,
    "src": "/* Released under the MIT license*\n *\n *  This code is released under the mit license and this should \n *  alwas be include along with any copy or usage or amending of \n *  the code\n */\nvar root = this;\n\nvar _ = require('stackq');\nvar grid = require('grids');\nvar domain = require('./domain');\n\n//create inplace holder to allow internal server and client usage\nvar isBrowser = _.valids.contains(root,'window');\nvar win = isBrowser ? root['window'] : { };\nwin.doc = isBrowser ? win['document'] : {};\n\nmodule.exports = _.Mask(function(){\n\n  var self = this;\n\n  this.Element = _.Immutate.extends({\n    init: function(map,component){\n      domain.ElementType.is(map,function(s,r){\n        _.Asserted(s,_.Util.String(' ',_.Util.toJSON(r),'does not match critera for elem creation'));\n      });\n\n      this.$super(map);\n      this.tag = map.type;\n      this.component = component;\n    },\n    isElement: function(){\n      return true;\n    },\n  });\n\n  this.unsecure('tagMixer',function(t,fx,joina){\n    return this.bind(function(f,v){\n      var j = [t,v].join(joina);\n      return fx.call(this,j,f);\n    });\n  });\n\n  this.unsecure('createElement',function(map){\n    return this.Element.make(map);\n  });\n\n  this.unsecure('renderHTML',function(elem){\n    var cache = {},done = [],tag = elem.snapshot('type');\n    \n    var attr = elem.snapshot('attr',this.bind(function(attr){\n      return attr.map(this.tagMixer('',function equa(nt,f){\n        if(f.isValueCursor()) return [nt,_.funcs.doubleQuote(f.value())].join('=');\n        return f.map(this.tagMixer(nt,equa,'-')).values().join(' ');\n      },''));\n    }));\n\n    var data = elem.snapshot('data',this.bind(function(data){\n      return data.map(this.tagMixer('data',function equa(nt,f){\n        if(f.isValueCursor()) return [nt,_.funcs.doubleQuote(f.value())].join('=');\n        return f.map(this.tagMixer(nt,equa,'-')).values().join(' ');\n      },'-'));\n    }));\n\n    var kids = elem.snapshot('children',this.bind(function(kids){\n       return kids.map(this.bind(function(f){\n\n         if(_.valids.isPrimitive(f)) return f;\n\n         var isc = _.GhostCursor.instanceBelongs(f);\n\n         if(f.isValueCursor()) return f.value();\n         if(f.isObjectCursor()){\n\n           if(this.Element.instanceBelongs(f.owner)){\n             if(done.indexOf(f) !== -1) return;\n             done.push(f);\n             return this.renderHTML(f.owner).markup;\n           }\n\n           //if its not an Element when build,cache and render\n           var el,map = f.value();\n           if(_.valids.contains(cache,map)) return;\n             // return this.renderHTML(cache[map]).markup;\n           try{\n             el = this.createElement(map);\n             cache[map] = el;\n           }catch(e){\n            return;\n           }\n           if(el) return this.renderHTML(el).markup;\n         }\n       }));\n    }));\n\n\n    var f = tag.map(function(f){\n      var build = ['<',f], props = [], content = [];\n      if(attr){ props.push(' '); props.push(attr.values().join(' ')); }\n      if(data){ props.push(' '); props.push(data.values().join(' ')); }\n      if(kids) content.push(kids.values().join(' '));\n      build.push(props.join(''));\n      build.push('>');\n      build.push('');\n      build.push(content.join(' '));\n      build.push(['</',f,'>'].join(''))\n      return build.join('');\n    });\n  \n    return {\n      elemCache: cache,\n      markup: f.values().join('')\n    };\n  });\n\n  this.unsecure('transformHTMl',function(markup){\n  });\n\n\n  this.Rendering = _.Configurable.extends({\n    init: function(comp){\n      _.Asserted(self.Component.instanceBelongs(comp),'only magnus.Component instance allowed')\n      this.component = comp;\n      this.hash = null;\n      this.cache = null;\n    },\n    render: function(){\n      if(this.component.hash() === this.hash){\n        if(_.valids.exists(this.cache)) return this.cache.markup\n        this.cache = self.renderHTML(this.component.element());\n        return this.cache.markup;\n      }\n      this.hash = this.component.hash();\n      this.cache = self.renderHTML(this.component.element());\n      return this.cache.markup;\n    },\n  },{\n    select: function(comp){\n      if(!!isBrowser) return self.ClientRender.make(comp);\n      return self.ServerRender.make(comp);\n    }\n  });\n\n  this.ServerRender = this.Rendering.extends({\n    init: function(comp){\n      this.$super(comp);\n    }\n  });\n\n  this.ClientRender = this.Rendering.extends({\n    init: function(comp){\n      core.Assert(isBrowser,'only works client sided with an html dom');\n      this.$super(comp);\n      this.fragment = doc.createElement();\n    }\n  });\n\n  this.RenderTree = _.Configurable.extends({\n    init: function(component){\n    },\n    render: function(){\n      \n    },\n  });\n\n  this.Component = _.Configurable.extends({\n    init: function(type,map,fn){\n      domain.ComponentArg.is(map,function(s,r){\n        _.Asserted(s,_.Util.String(' ','map does not match component critera: '+_.Util.toJSON(r)));\n      });\n      this.map = map;\n      this.type = type;\n      this.atom = map.atom;\n      \n      var res = {};\n      res.type = this.type;\n      if(map.attr) res.attr = this.map.attr;\n      if(map.data) res.data = this.map.data;\n\n      // if(res.data) res.data.hash = this.atom.hash();\n      // else{ res.data = { hash: this.atom.hash() };  };\n      var kids = fn.call(this,res);\n      domain.ResultType.is(res,function(s,r){\n        _.Asserted(s,_.Util.String(' ','result is not a map',_.funcs.toJSON(r)));\n      });\n      \n      if(_.valids.exists(kids)){\n        if(_.Cursor.instanceBelongs(kids)) res.children = kids;\n        else{\n          var rep = _.valids.List(kids) ? kids : [kids];\n          res.children = _.Sequence.value(rep).mapobj(function(v){\n             if(self.Component.instanceBelongs(v)) return v.element();\n             return v;\n          }).values();\n        }\n      };\n\n      //adds component meta details\n      this.elem = self.createElement(res,this);\n      //add rendering handler and configuration\n      this.rendering = self.Rendering.select(this);\n      map.type = type;\n    },\n    element: function(){\n      return this.elem;\n    },\n    hash: function(){\n     return this.elem.ghost().sHash();\n    },\n    data: function(){\n      return this.atom;\n    },\n    render: function(){\n      return this.rendering.render();\n    },\n  });\n\n});\n\n\n\n",
    "deps": {
      "./domain": "domain.js"
    },
    "entry": true
  },
  "domain.js": {
    "id": "domain.js",
    "type": "js",
    "mtime": 1423602778000,
    "src": "var _ = require('stackq');\nvar domain = module.exports = {};\n\n\ndomain.ResultType = _.Checker.orType(_.valids.Primitive,_.valids.Object,_.valids.List);\n\ndomain.ComponentArg = _.Checker({\n  atom: _.Cursor.instanceBelongs,\n  data: _.funcs.maybe(_.valids.Object),\n  attr: _.funcs.maybe(_.valids.Object),\n});\n\ndomain.ElementType = _.Checker({\n  type: _.valids.String,\n  data: _.funcs.maybe(_.valids.Object),\n  attr: _.funcs.maybe(_.valids.Object),\n});\n",
    "deps": {}
  }
}